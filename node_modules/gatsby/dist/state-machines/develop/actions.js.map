{"version":3,"sources":["../../../src/state-machines/develop/actions.ts"],"names":["callRealApi","event","store","type","payload","resolve","actions","action","result","dispatch","reporter","log","callApi","addNodeMutation","nodeMutationBatch","push","assignStoreAndWorkerPool","_context","workerPool","data","setQueryRunningFinished","boundActionCreators","setProgramStatus","ProgramStatus","BOOTSTRAP_QUERY_RUNNING_FINISHED","markQueryFilesDirty","queryFilesDirty","assignServiceResult","spawnMutationListener","mutationListener","listenForMutations","assignServers","assignWebhookBody","webhookBody","clearWebhookBody","undefined","finishParentSpan","parentSpan","finish","saveDbState","markNodesDirty","nodesMutatedDuringQueryRun","buildActions"],"mappings":"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","sourcesContent":["import {\n  assign,\n  AnyEventObject,\n  ActionFunction,\n  spawn,\n  ActionFunctionMap,\n  DoneEventObject,\n} from \"xstate\"\nimport { Store } from \"redux\"\nimport { IBuildContext, IMutationAction } from \"../../services\"\nimport { actions, boundActionCreators } from \"../../redux/actions\"\nimport { listenForMutations } from \"../../services/listen-for-mutations\"\nimport { DataLayerResult } from \"../data-layer\"\nimport { assertStore } from \"../../utils/assert-store\"\nimport { saveState } from \"../../db\"\nimport reporter from \"gatsby-cli/lib/reporter\"\nimport { ProgramStatus } from \"../../redux/types\"\n\n/**\n * These are the deferred redux actions sent from api-runner-node\n * They may include a `resolve` prop (if they are createNode actions).\n * If so, we resolve the promise when we're done\n */\nexport const callRealApi = (event: IMutationAction, store?: Store): void => {\n  assertStore(store)\n  const { type, payload, resolve } = event\n  if (type in actions) {\n    // If this is a createNode action then this will be a thunk.\n    // No worries, we just dispatch it like any other\n    const action = actions[type](...payload)\n    const result = store.dispatch(action)\n    // Somebody may be waiting for this\n    if (resolve) {\n      resolve(result)\n    }\n  } else {\n    reporter.log(`Could not dispatch unknown action \"${type}`)\n  }\n}\n\n/**\n * Handler for when we're inside handlers that should be able to mutate nodes\n * Instead of queueing, we call it right away\n */\nexport const callApi: ActionFunction<IBuildContext, AnyEventObject> = (\n  { store },\n  event\n) => callRealApi(event.payload, store)\n\n/**\n * Event handler used in all states where we're not ready to process node\n * mutations. Instead we add it to a batch to process when we're next idle\n */\nexport const addNodeMutation = assign<IBuildContext, AnyEventObject>({\n  nodeMutationBatch: ({ nodeMutationBatch = [] }, { payload }) => {\n    // It's not pretty, but it's much quicker than concat\n    nodeMutationBatch.push(payload)\n    return nodeMutationBatch\n  },\n})\n\nexport const assignStoreAndWorkerPool = assign<IBuildContext, DoneEventObject>(\n  (_context, event) => {\n    const { store, workerPool } = event.data\n    return {\n      store,\n      workerPool,\n    }\n  }\n)\n\nconst setQueryRunningFinished = async (): Promise<void> => {\n  boundActionCreators.setProgramStatus(\n    ProgramStatus.BOOTSTRAP_QUERY_RUNNING_FINISHED\n  )\n}\n\nexport const markQueryFilesDirty = assign<IBuildContext>({\n  queryFilesDirty: true,\n})\n\nexport const assignServiceResult = assign<IBuildContext, DoneEventObject>(\n  (_context, { data }): DataLayerResult => data\n)\n\n/**\n * This spawns the service that listens to the `emitter` for various mutation events\n */\nexport const spawnMutationListener = assign<IBuildContext>({\n  mutationListener: () => spawn(listenForMutations, `listen-for-mutations`),\n})\n\nexport const assignServers = assign<IBuildContext, AnyEventObject>(\n  (_context, { data }) => {\n    return {\n      ...data,\n    }\n  }\n)\n\nexport const assignWebhookBody = assign<IBuildContext, AnyEventObject>({\n  webhookBody: (_context, { payload }) => payload?.webhookBody,\n})\n\nexport const clearWebhookBody = assign<IBuildContext, AnyEventObject>({\n  webhookBody: undefined,\n})\n\nexport const finishParentSpan = ({ parentSpan }: IBuildContext): void =>\n  parentSpan?.finish()\n\nexport const saveDbState = (): Promise<void> => saveState()\n\n/**\n * Event handler used in all states where we're not ready to process a file change\n * Instead we add it to a batch to process when we're next idle\n */\n// export const markFilesDirty: BuildMachineAction = assign<IBuildContext>({\n//   filesDirty: true,\n// })\n\nexport const markNodesDirty = assign<IBuildContext>({\n  nodesMutatedDuringQueryRun: true,\n})\n\nexport const buildActions: ActionFunctionMap<IBuildContext, AnyEventObject> = {\n  callApi,\n  markNodesDirty,\n  addNodeMutation,\n  spawnMutationListener,\n  assignStoreAndWorkerPool,\n  assignServiceResult,\n  assignServers,\n  markQueryFilesDirty,\n  assignWebhookBody,\n  clearWebhookBody,\n  finishParentSpan,\n  saveDbState,\n  setQueryRunningFinished,\n}\n"],"file":"actions.js"}